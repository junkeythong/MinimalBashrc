# ============================================================================
# ENVIRONMENT VARIABLES
# ============================================================================

# Kubernetes Configuration
export DEFAULT_NS='default_working_ns'
export DEFAULT_CONTEXT="default_working_context"

# Set kubectl namespace if not already set
if [[ ! $KUBECTL_NS ]]; then
    export KUBECTL_NS="$DEFAULT_NS"
fi
export KUBECTL_NS_PARAM="--namespace $KUBECTL_NS"

# ============================================================================
# COLOR DEFINITIONS
# ============================================================================

# Terminal colors for prompt customization
COL="\[\e[1;30m\]"
RED="\[\e[01;31m\]"
GREEN="\[\e[01;32m\]"
YELLOW="\[\e[01;33m\]"
BLUE="\[\e[01;34m\]"
REVERSE_BLUE="\[\e[07;34m\]"
PURPLE="\[\e[01;35m\]"
CYAN="\[\e[01;36m\]"
WHITE="\[\e[01;37m\]"
BLINK_WHITE_ON_RED="\[\e[5m\e[41m\e[37m\]"
ITALIC_GREEN="\[\e[03;32m\]"
ITALIC_CYAN="\[\e[03;36m\]"
DARK_GRAY="\[\e[01;30m\]"
BRIGHT_YELLOW="\[\e[01;33m\]"
RESET="\[\e[0m\]"

# ============================================================================
# BASIC ALIASES
# ============================================================================

# Navigation shortcuts
alias ..='cd ..'
alias ...='cd ../..'

# Enhanced ls
alias ll='ls -la'
alias la='ls -A'
alias l='ls -CF'

# Safe file operations (interactive mode)
alias cp='cp --interactive'
alias mv='mv --interactive'
alias rm='rm --interactive'

# Alternative: Move to Trash instead of rm (Linux)
# Uncomment the line below if you prefer trash over rm
# alias rm='mv -t ~/.Trash'

# ============================================================================
# GIT ALIASES AND FUNCTIONS
# ============================================================================

# Git shortcuts
alias gits='git status'
alias gitb='git branch'
alias gitc='git checkout'
alias gitl='git log --oneline'

# Git pull with submodule update
gitp() {
    git pull "$@" && git submodule update --init --recursive
}

# Git push wrapper
gitpush() {
    git push "$@"
}

# Get modified files in current commit
gitchanges() {
    git log -1 --name-only --pretty=format:"" | grep -v '^$'
}

# Quick amend to current commit
gitamend() {
    git commit --amend --no-edit
}

# Compare local, fetch, and remote heads
headsgit() {
    if ! git rev-parse --is-inside-work-tree &>/dev/null; then
        echo "Not inside a Git repository"
        return 1
    fi

    local branch=$(git symbolic-ref --short HEAD 2>/dev/null || echo "(detached HEAD)")
    local remote="origin"
    local format="%C(auto)%h %an %ad %s"

    echo "Current LOCAL branch: $branch"

    # Fetch latest changes
    git fetch $remote $branch &>/dev/null

    # Display commit information
    local local_head=$(git --no-pager show -s --format="$format" HEAD)
    local fetch_head="(No FETCH_HEAD - run 'git fetch')"

    if [ -f .git/FETCH_HEAD ]; then
        fetch_head=$(git --no-pager show -s --format="$format" FETCH_HEAD 2>/dev/null)
    fi

    local remote_head="Remote branch: $remote/$branch not found"
    if git rev-parse --verify "$remote/$branch" &>/dev/null; then
        remote_head=$(git --no-pager show -s --format="$format" "$remote/$branch")
    fi

    printf "%-13s %s\n" "LOCAL HEAD:" "$local_head"
    printf "%-13s %s\n" "FETCH HEAD:" "$fetch_head"
    printf "%-13s %s\n" "REMOTE HEAD:" "$remote_head"

    echo "Remote branches:"
    git branch -r --format="%(refname:short)" | sort
}

# ============================================================================
# KUBERNETES FUNCTIONS
# ============================================================================

# List namespaces sorted by creation time
ns() {
    kubectl get ns "$@" --sort-by=.metadata.creationTimestamp
}

# List pods in current namespace
po() {
    kubectl get pods $KUBECTL_NS_PARAM "$@"
}

# Get containers in a pod
ctn() {
    local pod_name=$1
    if [[ ! $pod_name ]]; then
        echo "Usage: ctn <pod_name>"
        echo "Gets all containers in the specified pod"
        return 1
    fi

    local list_containers=$(kubectl get pod "$pod_name" -o jsonpath='{.spec.initContainers[*].name}{"\n"}{.spec.containers[*].name}' $KUBECTL_NS_PARAM 2>/dev/null)

    if [[ ! $list_containers ]]; then
        echo "Failed to get container list in Pod $pod_name!"
        return 1
    fi

    echo "Containers in pod $pod_name:"
    for container in $list_containers; do
        echo "  - $container"
    done
}

# Switch kubectl namespace
kns() {
    local new_ns=$1

    # Show current namespace if no argument provided
    if [[ ! $new_ns ]]; then
        echo "Current namespace: $KUBECTL_NS"
        return 0
    fi

    # Check cluster connectivity
    if ! kubectl cluster-info > /dev/null 2>&1; then
        echo "Cannot connect to the cluster. Cannot switch namespace."
        return 1
    fi

    # Check if namespace exists
    if kubectl get ns "$new_ns" > /dev/null 2>&1; then
        export KUBECTL_NS="$new_ns"
        export KUBECTL_NS_PARAM="--namespace $KUBECTL_NS"
        alias k="kubectl $KUBECTL_NS_PARAM"
        alias h="helm $KUBECTL_NS_PARAM"
        echo "Switched to namespace: $KUBECTL_NS"
    else
        echo "Namespace $new_ns does not exist. Current namespace: $KUBECTL_NS"
    fi
}

# Switch kubeconfig for multiple clusters
ek() {
    local home_kube=~/.kube
    local new_kube=$1

    if [[ ! $new_kube ]]; then
        echo "Current kubeconfig: $KUBECONFIG"
        echo "Available configs:"
        ls -1 "$home_kube"/*.yaml 2>/dev/null | xargs -n1 basename | sed 's/.yaml$//'
        return 0
    fi

    if [[ ! -f "$home_kube/$new_kube.yaml" ]]; then
        echo "$home_kube/$new_kube.yaml does not exist"
        echo "Current kubeconfig: $KUBECONFIG"
        return 1
    fi

    export KUBECONFIG="$home_kube/$new_kube.yaml"
    echo "Switched to kubeconfig: $new_kube"
}

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

# Quick directory navigation (customize paths as needed)
cd1() {
    cd /path/to/main_repo || echo "Path /path/to/main_repo not found"
}

cd2() {
    cd /path/to/test_repo || echo "Path /path/to/test_repo not found"
}

# Quick bashrc editing and sourcing
editbash() {
    ${EDITOR:-vi} ~/.bashrc
}

sourcebash() {
    source ~/.bashrc
    echo "Bashrc reloaded"
}

# Sync repositories
reposync() {
    local source="/your/main-repo"
    local dest="/your/test-repo"

    if [[ ! -d "$source" ]]; then
        echo "Source directory $source not found"
        return 1
    fi

    rsync -aPv "$source/" "$dest/"
    echo "Repository sync completed"
}

# Get Bitcoin price
get_btc_price() {
    curl -s https://api.coinbase.com/v2/prices/BTC-USD/spot | jq -r '.data.amount' 2>/dev/null || echo "N/A"
}

# Count running Docker containers
docker_count() {
    docker ps -q 2>/dev/null | wc -l | tr -d ' '
}

# Count active screen sessions
screen_count() {
    screen -ls 2>/dev/null | awk '/[0-9]+\./ {c++} END{print c+0}'
}

# ============================================================================
# PROMPT HELPER FUNCTIONS
# ============================================================================

# Get current git branch
parse_git_branch() {
    if git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'
    fi
}

# Get last commit message
get_last_commit_message() {
    if git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        git log -1 --oneline | cut -d ' ' -f2-
    fi
}

# Get current Kubernetes context
get_k8s_context() {
    kubectl config get-contexts --no-headers=true 2>/dev/null | grep '*' | awk '{print $2}' || echo "N/A"
}

# ============================================================================
# KUBERNETES INITIALIZATION
# ============================================================================

# Initialize default namespace if connected to cluster
if kubectl cluster-info > /dev/null 2>&1; then
    if ! kubectl get ns $DEFAULT_NS > /dev/null 2>&1; then
        if kubectl create ns $DEFAULT_NS > /dev/null 2>&1; then
            echo "Namespace $DEFAULT_NS created successfully."
        else
            echo "Failed to create namespace $DEFAULT_NS."
        fi
    fi
else
    echo "Cannot connect to Kubernetes cluster. Skipping namespace initialization."
fi

# ============================================================================
# CUSTOM PROMPT CONFIGURATION
# ============================================================================

# Dynamic prompt reload function
reload_ps() {
    local curr_config="$(get_k8s_context)"
    local curr_branch="$(parse_git_branch)"

    # Kubernetes context formatting
    if [[ "$curr_config" != "$DEFAULT_CONTEXT" ]]; then
        context_format="${REVERSE_BLUE}<\$(get_k8s_context)>${RESET}"
    else
        context_format="${BLUE}<\$(get_k8s_context)>${RESET}"
    fi

    # Git branch formatting (highlight master/main branches)
    if [[ "$curr_branch" == "(master)" ]] || [[ "$curr_branch" == "(main)" ]]; then
        branch_format="${BLINK_WHITE_ON_RED}\$(parse_git_branch)${RESET}"
    else
        branch_format="${ITALIC_GREEN}\$(parse_git_branch)${RESET}"
    fi

    # Namespace formatting (highlight default namespace)
    if [[ "$KUBECTL_NS" == "default" ]]; then
        namespace_format="${BLINK_WHITE_ON_RED}(\$(kns))${RESET}"
    else
        namespace_format="${ITALIC_CYAN}(\$(kns))${RESET}"
    fi

    # Additional prompt components
    local btc_format="${GREEN}(\$(get_btc_price))${RESET}"
    local time_format="${RED}(\t)${RESET}"
    local host_format="${PURPLE}(\h)${RESET}"
    local commit_message_format="${DARK_GRAY}(\$(get_last_commit_message))${RESET}"
    local path_format="${WHITE}[\w]${RESET}"
    local screen_format="${BRIGHT_YELLOW}\$(echo \$STY)${RESET}"

    # SSH/Local indicator
    if [[ -n "$SSH_CLIENT" || -n "$SSH_CONNECTION" ]]; then
        local whereami_format="🌐 ${RED}VPS${RESET}"
    else
        local whereami_format="💻 ${GREEN}Local${RESET}"
    fi

    # Docker and screen count
    local docker_screen_count_format="${WHITE}[containers:\$(docker_count) screens:\$(screen_count)]${RESET}"

    # Construct final PS1
    PS1="${whereami_format}${btc_format}${docker_screen_count_format}${time_format}${host_format}${context_format}${namespace_format}${branch_format}${commit_message_format}${path_format}${screen_format} \n--> ${COL}"
}

# Set prompt command to reload on each command
PROMPT_COMMAND='reload_ps'

# ============================================================================
# INITIALIZATION
# ============================================================================

# Set default namespace and navigate to main directory
kns $DEFAULT_NS 2>/dev/null
cd1 2>/dev/null